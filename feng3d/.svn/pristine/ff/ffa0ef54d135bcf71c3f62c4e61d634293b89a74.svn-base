package me.feng3d.core.partition
{
	import me.feng3d.arcane;
	import me.feng3d.core.traverse.PartitionTraverser;
	import me.feng3d.entities.Entity;

	use namespace arcane;

	/**
	 * 3D空间分区
	 * <p>用于把3D空间分区，便于搜索出有必要渲染的对象，从而优化性能</p>
	 * @author warden_feng 2015-3-5
	 */
	public class Partition3D
	{
		protected var _rootNode:NodeBase;
		private var _updatesMade:Boolean;
		private var _updateQueue:EntityNode;

		/**
		 * 创建一个3D空间分区
		 * @param rootNode	根节点
		 */
		public function Partition3D(rootNode:NodeBase)
		{
			_rootNode = rootNode || new NullNode();
		}

		/**
		 * 发送一个横越者穿过分区树
		 * @param traverser		横越者
		 */
		public function traverse(traverser:PartitionTraverser):void
		{
			if (_updatesMade)
				updateEntities();

			++PartitionTraverser._collectionMark;

			_rootNode.acceptTraverser(traverser);
		}

		/**
		 * 从分区树种移除实体
		 * @param entity 被移除实体
		 */
		arcane function removeEntity(entity:Entity):void
		{
			var node:EntityNode = entity.getEntityPartitionNode();
			var t:EntityNode;

			node.removeFromParent();

			if (node == _updateQueue)
				_updateQueue = node._updateQueueNext;
			else
			{
				t = _updateQueue;
				while (t && t._updateQueueNext != node)
					t = t._updateQueueNext;
				if (t)
					t._updateQueueNext = node._updateQueueNext;
			}

			node._updateQueueNext = null;

			if (!_updateQueue)
				_updatesMade = false;
		}

		/**
		 * 标记更新
		 * @param entity	更新的实体
		 */
		arcane function markForUpdate(entity:Entity):void
		{
			var node:EntityNode = entity.getEntityPartitionNode();
			// already marked to be updated
			var t:EntityNode = _updateQueue;

			// if already marked for update
			while (t)
			{
				if (node == t)
					return;

				t = t._updateQueueNext;
			}

			node._updateQueueNext = _updateQueue;

			_updateQueue = node;
			_updatesMade = true;
		}

		/**
		 * 更新实体
		 */
		private function updateEntities():void
		{
			var node:EntityNode = _updateQueue;
			var targetNode:NodeBase;
			var t:EntityNode;

			// clear updateQueue early to allow for newly marked entity updates
			_updateQueue = null;
			_updatesMade = false;

			do
			{
				targetNode = _rootNode.findPartitionForEntity(node.entity);

				// if changed, find and attach the mesh node to the best suited partition node
				if (node.parent != targetNode)
				{
					if (node)
						node.removeFromParent();

					targetNode.addNode(node);
				}

				t = node._updateQueueNext;
				node._updateQueueNext = null;

				//call an internal update on the entity to fire any attached logic
				node.entity.internalUpdate();

			} while ((node = t) != null);
		}
	}
}
