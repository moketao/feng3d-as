package me.feng3d.containers
{
	import flash.utils.Dictionary;

	import me.feng3d.arcane;
	import me.feng3d.core.base.Object3D;
	import me.feng3d.core.partition.NodeBase;
	import me.feng3d.core.partition.Partition3D;
	import me.feng3d.core.traverse.PartitionTraverser;
	import me.feng3d.entities.Entity;

	use namespace arcane;

	/**
	 * 3d场景
	 * @author warden_feng 2014-3-17
	 */
	public class Scene3D extends ObjectContainer3D
	{
		private var _partitions:Vector.<Partition3D>;

		/** 实体字典 */
		private var _entityDic:Dictionary;

		private var _displayEntityDic:Dictionary;

		private var _mouseCollisionEntitys:Vector.<Entity>;

		public function Scene3D()
		{
			_isRoot = true;
			_scene = this;

			_entityDic = new Dictionary();
			_displayEntityDic = new Dictionary();
			_mouseCollisionEntitys = new Vector.<Entity>();

			_partitions = new Vector.<Partition3D>();

			partition = new Partition3D(new NodeBase());
		}

		/** 显示实体字典 */
		public function get displayEntityDic():Dictionary
		{
			return _displayEntityDic;
		}

		arcane function addedObject3d(object3D:Object3D):void
		{
			if (object3D is Entity)
			{
				_entityDic[object3D.name] = object3D;
				if (object3D.visible)
				{
					_displayEntityDic[object3D.name] = object3D;
				}
			}
		}

		arcane function removedObject3d(object3D:Object3D):void
		{
			delete _entityDic[object3D.name];
			delete _displayEntityDic[object3D.name];
		}

		/**
		 * 收集需要检测鼠标碰撞的实体
		 */
		public function collectMouseCollisionEntitys():void
		{
			_mouseCollisionEntitys.length = 0;

			//3d对象堆栈
			var mouseCollisionStack:Vector.<Object3D> = new Vector.<Object3D>();
			mouseCollisionStack.push(this);

			var object3D:Object3D;
			var entity:Entity;
			var container3D:ObjectContainer3D;
			//遍历堆栈中需要检测鼠标碰撞的实体
			while (mouseCollisionStack.length > 0)
			{
				object3D = mouseCollisionStack.pop();
				if (!object3D.visible)
					continue;
				entity = object3D as Entity;
				container3D = object3D as ObjectContainer3D;
				//收集需要检测鼠标碰撞的实体到检测列表
				if (entity && entity.mouseEnabled)
				{
					_mouseCollisionEntitys.push(object3D as Entity);
				}
				//收集容器内子对象到堆栈
				if (container3D && container3D.mouseChildren)
				{
					var len:uint = container3D.numChildren;
					for (var i:int = 0; i < len; i++)
					{
						mouseCollisionStack.push(container3D.getChildAt(i));
					}
				}
			}
		}

		/**
		 * 需要检测鼠标碰撞的实体
		 */
		public function get mouseCollisionEntitys():Vector.<Entity>
		{
			return _mouseCollisionEntitys;
		}

		/**
		 * Sends a PartitionTraverser object down the scene partitions
		 * @param traverser The traverser which will pass through the partitions.
		 *
		 * @see away3d.core.traverse.PartitionTraverser
		 * @see away3d.core.traverse.EntityCollector
		 */
		public function traversePartitions(traverser:PartitionTraverser):void
		{
			var i:uint;
			var len:uint = _partitions.length;

			traverser.scene = this;

			while (i < len)
				_partitions[i++].traverse(traverser);
		}

		/**
		 * When an entity is removed from the scene, or from one of its children, remove it from its former partition tree.
		 * @private
		 */
		arcane function unregisterEntity(entity:Entity):void
		{
			entity.implicitPartition.removeEntity(entity);
		}

		/**
		 * When an entity is added to the scene, or to one of its children, add it to the partition tree.
		 * @private
		 */
		arcane function registerEntity(entity:Entity):void
		{
			var partition:Partition3D = entity.implicitPartition;
			addPartitionUnique(partition);

			partition.markForUpdate(entity);
		}

		/**
		 * Add a partition if it's not in the list
		 */
		protected function addPartitionUnique(partition:Partition3D):void
		{
			if (_partitions.indexOf(partition) == -1)
				_partitions.push(partition);
		}

		/**
		 * When a partition is assigned to an object somewhere in the scene graph, add the partition to the list if it isn't in there yet
		 */
		arcane function registerPartition(entity:Entity):void
		{
			addPartitionUnique(entity.implicitPartition);
		}

		/**
		 * When a partition is removed from an object somewhere in the scene graph, remove the partition from the list
		 */
		arcane function unregisterPartition(entity:Entity):void
		{
			// todo: wait... is this even correct?
			// shouldn't we check the number of children in implicitPartition and remove partition if 0?
			entity.implicitPartition.removeEntity(entity);
		}
	}
}
