package me.feng3d.fagal.vertex
{
	import me.feng3d.animators.AnimationType;
	import me.feng3d.core.buffer.Context3DBufferTypeID;
	import me.feng3d.core.register.Register;
	import me.feng3d.fagal.base.requestRegister;
	import me.feng3d.fagal.methods.FagalVertexMethod;
	import me.feng3d.fagal.vertex.animation.V_SkeletonAnimationCPU;
	import me.feng3d.fagal.vertex.animation.V_SkeletonAnimationGPU;
	import me.feng3d.fagal.vertex.animation.V_VertexAnimationCPU;
	import me.feng3d.fagal.vertex.animation.V_VertexAnimationGPU;
	import me.feng3d.fagal.vertex.particle.V_Particles;

	/**
	 * 顶点渲染程序主入口
	 * @author warden_feng 2014-10-30
	 */
	public class V_Main extends FagalVertexMethod
	{
		override public function runFunc():void
		{
			//生成动画代码
			var animatedPosition:Register = buildAnimationAGAL();

			//顶点世界坐标
			var positionSceneReg:Register;

			if (shaderParams.needWorldPosition)
				positionSceneReg = V_WorldPosition();

			if (shaderParams.usesGlobalPosFragment)
				V_WorldPositionOut(positionSceneReg);

			//计算投影坐标
			V_BaseOut();

			//输出数据到片段寄存器
			if (shaderParams.needsUV)
			{
				//uv数据
				var uv:Register = requestRegister(Context3DBufferTypeID.UV_VA_2);
				//uv变量数据
				var uv_v:Register = requestRegister(Context3DBufferTypeID.UV_V);
				mov(uv_v, uv);
			}

			if (shaderParams.needsNormals)
			{

				if (shaderParams.hasNormalTexture)
				{
					//法线数据
					var normalInput:Register = requestRegister(Context3DBufferTypeID.NORMAL_VA_3);
					//切线数据
					var tangentInput:Register = requestRegister(Context3DBufferTypeID.TANGENT_VA_3);
					//法线场景变换矩阵(模型空间转场景空间)
					var matrix:Register = requestRegister(Context3DBufferTypeID.NORMALSCENETRANSFORM_VC_MATRIX);
					//切线变量寄存器
					var tangentVarying:Register = requestRegister(Context3DBufferTypeID.TANGENT_V);
					//双切线变量寄存器
					var bitangentVarying:Register = requestRegister(Context3DBufferTypeID.BITANGENT_V);
					//法线变量寄存器
					var normalVarying:Register = requestRegister(Context3DBufferTypeID.NORMAL_V);

					V_TangentNormalMap(normalInput, tangentInput, matrix, normalVarying, tangentVarying, bitangentVarying);
				}
				else
				{
					//法线数据
					var animatedNormalReg:Register = requestRegister(Context3DBufferTypeID.NORMAL_VA_3);
					//法线变量寄存器
					var normalVaryingReg:Register = requestRegister(Context3DBufferTypeID.NORMAL_V);
					//法线场景变换矩阵(模型空间转场景空间)
					var normalMatrixReg:Register = requestRegister(Context3DBufferTypeID.NORMALSCENETRANSFORM_VC_MATRIX);

					V_TangentNormalNoMap(animatedNormalReg, normalVaryingReg, normalMatrixReg);
				}
			}

			if (shaderParams.needsViewDir)
			{
				//顶点世界坐标
				var globalPositionReg:Register = requestRegister(Context3DBufferTypeID.GLOBALPOSITION_VT_4);
				//视线变量寄存器
				var viewDirVaryingReg:Register = requestRegister(Context3DBufferTypeID.VIEWDIR_V);
				//摄像机世界坐标
				var cameraPositionReg:Register = requestRegister(Context3DBufferTypeID.CAMERAPOSITION_VC_VECTOR);
				V_ViewDir(globalPositionReg, viewDirVaryingReg, cameraPositionReg);
			}
		}

		/**
		 * 生成动画代码
		 */
		protected function buildAnimationAGAL():Register
		{
			//动画后的顶点坐标数据
			var animatedPosition:Register = requestRegister(Context3DBufferTypeID.ANIMATEDPOSITION_VT_4);

			switch (shaderParams.animationType)
			{
				case AnimationType.NONE:
					V_BaseAnimation(animatedPosition);
					break;
				case AnimationType.VERTEX_CPU:
					V_VertexAnimationCPU(animatedPosition);
					break;
				case AnimationType.VERTEX_GPU:
					V_VertexAnimationGPU(animatedPosition);
					break;
				case AnimationType.SKELETON_CPU:
					V_SkeletonAnimationCPU(animatedPosition);
					break;
				case AnimationType.SKELETON_GPU:
					V_SkeletonAnimationGPU(animatedPosition);
					break;
				case AnimationType.PARTICLE:
					V_Particles(animatedPosition);
					break;
				default:
					throw new Error(AnimationType.PARTICLE + "类型动画缺少FAGAL代码");
					break;
			}
			return animatedPosition;
		}
	}
}
