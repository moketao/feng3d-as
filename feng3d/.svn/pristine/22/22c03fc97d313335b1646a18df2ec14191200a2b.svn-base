package me.feng3d.fagal.fragment.light
{
	import me.feng3d.core.buffer.Context3DBufferTypeID;
	import me.feng3d.core.register.Register;
	import me.feng3d.core.register.RegisterVector;
	import me.feng3d.fagal.base.comment;
	import me.feng3d.fagal.base.getFreeTemp;
	import me.feng3d.fagal.base.removeTemp;
	import me.feng3d.fagal.base.requestRegister;
	import me.feng3d.fagal.base.requestRegisterVector;
	import me.feng3d.fagal.base.operation.dp3;
	import me.feng3d.fagal.base.operation.mul;
	import me.feng3d.fagal.base.operation.nrm;
	import me.feng3d.fagal.base.operation.sat;
	import me.feng3d.fagal.base.operation.sub;
	import me.feng3d.fagal.methods.FagalRE;
	import me.feng3d.fagal.params.ShaderParams;

	/**
	 * 点光源渲染
	 * @author warden_feng 2014-11-8
	 */
	public function F_PointLight(globalPosVaryReg:Register):void
	{
		var shaderParams:ShaderParams = FagalRE.instance.context3DCache.shaderParams;
		var numPointLights:int = shaderParams.numPointLights;
		//
		//点光源漫反射光颜色
		var pointLightDiffuseColorHeadReg:RegisterVector = requestRegisterVector(Context3DBufferTypeID.POINTLIGHTDIFFUSE_FC_VECTOR, numPointLights);
		//点光源场景位置
		var pointLightScenePosHeadReg:RegisterVector = requestRegisterVector(Context3DBufferTypeID.POINTLIGHTSCENEPOS_FC_VECTOR, numPointLights);
		//点光源镜面反射颜色
		var pointLightSpecularColorHeadReg:RegisterVector = requestRegisterVector(Context3DBufferTypeID.POINTLIGHTSPECULAR_FC_VECTOR, numPointLights);
		//光线方向
		var pointLightDirReg:Register;
		//点光源漫反射颜色寄存器
		var pointLightdiffuseColorReg:Register;
		//点光源镜面反射颜色寄存器
		var pointLightSpecularColorReg:Register;
		//点光源世界坐标寄存器
		var pointLightPosReg:Register;

		var regIndex:int;

		pointLightDirReg = getFreeTemp("光照方向");
		for (var i:uint = 0; i < numPointLights; ++i)
		{
			pointLightPosReg = pointLightScenePosHeadReg.getReg(i);
			pointLightdiffuseColorReg = pointLightDiffuseColorHeadReg.getReg(i);
			pointLightSpecularColorReg = pointLightSpecularColorHeadReg.getReg(i);

			comment("计算光照方向与光强");
			// 计算光衰减 （根据物体表面离光源的距离来计算光强）
			//物体表面到光源距离
			sub(pointLightDirReg, pointLightPosReg, globalPosVaryReg);
			// attenuate
			dp3(pointLightDirReg.w, pointLightDirReg, pointLightDirReg);
			// w = d - radis
			sub(pointLightDirReg.w, pointLightDirReg.w, pointLightdiffuseColorReg.w);
			// w = (d - radius)/(max-min) 
			mul(pointLightDirReg.w, pointLightDirReg.w, pointLightSpecularColorReg.w);
			// w = clamp(w, 0, 1)
			sat(pointLightDirReg.w, pointLightDirReg.w);
			// w = 1-w (w为光强)
			sub(pointLightDirReg.w, pointLightPosReg.w, pointLightDirReg.w);
			// normalize
			nrm(pointLightDirReg.xyz, pointLightDirReg); //

			//计算漫反射
			if (shaderParams.usingDiffuseMethod)
			{
				//总漫反射颜色寄存器
				var totalLightColorReg:Register = requestRegister(Context3DBufferTypeID.TOTALDIFFUSELIGHTCOLOR_FT_4);
				//法线临时片段寄存器
				var normalFragmentReg:Register = requestRegister(Context3DBufferTypeID.NORMAL_FT_4);
				//公用数据片段常量数据
				var commonsReg:Register = requestRegister(Context3DBufferTypeID.COMMONSDATA_FC_VECTOR);
				getDiffCodePerLight(pointLightDirReg, pointLightdiffuseColorReg, i == 0, totalLightColorReg, normalFragmentReg, commonsReg);
			}
			//计算镜面反射
			if (shaderParams.usingSpecularMethod)
			{
				//总镜面反射颜色寄存器
				var totalSpecularColorReg:Register = requestRegister(Context3DBufferTypeID.TOTALSPECULARLIGHTCOLOR_FT_4);
				//视线方向片段临时数据
				var viewDirReg:Register = requestRegister(Context3DBufferTypeID.VIEWDIR_FT_4);
				//光泽纹理数据片段临时寄存器
				var specularTexData:Register = requestRegister("specularTexData_ft_4");
				//材质镜面反射光数据
				var _specularDataRegister:Register = requestRegister(Context3DBufferTypeID.SPECULARDATA_FC_VECTOR);
				getSpecCodePerLight(pointLightDirReg, pointLightSpecularColorReg, i == 0, totalSpecularColorReg, viewDirReg, normalFragmentReg, specularTexData, _specularDataRegister);
			}
		}

		removeTemp(pointLightDirReg);
	}
}
