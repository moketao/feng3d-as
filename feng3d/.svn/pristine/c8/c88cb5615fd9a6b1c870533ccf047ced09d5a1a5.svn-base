package me.feng3d.core.render
{
	import flash.display3D.Context3D;
	import flash.display3D.Context3DCompareMode;
	import flash.display3D.textures.TextureBase;
	import flash.geom.Matrix3D;
	import flash.geom.Rectangle;

	import me.feng.error.AbstractMethodError;
	import me.feng3d.arcane;
	import me.feng3d.core.proxy.Stage3DProxy;
	import me.feng3d.core.sorter.IEntitySorter;
	import me.feng3d.core.traverse.EntityCollector;
	import me.feng3d.events.Stage3DEvent;

	use namespace arcane;

	/**
	 * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render geometry
	 * to the back buffer or a texture.
	 * @author warden_feng 2015-3-1
	 */
	public class RendererBase
	{
		protected var _context:Context3D;
		protected var _stage3DProxy:Stage3DProxy;

		protected var _backgroundR:Number = 0;
		protected var _backgroundG:Number = 0;
		protected var _backgroundB:Number = 0;
		protected var _backgroundAlpha:Number = 1;
		protected var _shareContext:Boolean = false;

		protected var _renderTarget:TextureBase;
		protected var _renderTargetSurface:int;

		protected var _viewWidth:Number;
		protected var _viewHeight:Number;

		protected var _renderableSorter:IEntitySorter;

		protected var _textureRatioX:Number = 1;
		protected var _textureRatioY:Number = 1;

		private var _clearOnRender:Boolean = true;
		protected var _rttViewProjectionMatrix:Matrix3D = new Matrix3D();

		/**
		 * Creates a new RendererBase object.
		 */
		public function RendererBase(renderToTexture:Boolean = false)
		{
		}

		/**
		 * The Stage3DProxy that will provide the Context3D used for rendering.
		 *
		 * @private
		 */
		arcane function get stage3DProxy():Stage3DProxy
		{
			return _stage3DProxy;
		}

		arcane function set stage3DProxy(value:Stage3DProxy):void
		{
			if (value == _stage3DProxy)
				return;

			if (!value)
			{
				if (_stage3DProxy)
				{
					_stage3DProxy.removeEventListener(Stage3DEvent.CONTEXT3D_CREATED, onContextUpdate);
					_stage3DProxy.removeEventListener(Stage3DEvent.CONTEXT3D_RECREATED, onContextUpdate);
				}
				_stage3DProxy = null;
				_context = null;
				return;
			}
			//else if (_stage3DProxy) throw new Error("A Stage3D instance was already assigned!");

			_stage3DProxy = value;
			_stage3DProxy.addEventListener(Stage3DEvent.CONTEXT3D_CREATED, onContextUpdate);
			_stage3DProxy.addEventListener(Stage3DEvent.CONTEXT3D_RECREATED, onContextUpdate);

			if (value.context3D)
				_context = value.context3D;
		}

		/**
		 * Assign the context once retrieved
		 */
		private function onContextUpdate(event:Stage3DEvent):void
		{
			_context = _stage3DProxy.context3D;
		}

		/**
		 * 创建一个实体集合
		 */
		arcane function createEntityCollector():EntityCollector
		{
			return new EntityCollector();
		}

		/**
		 * 窗口宽度
		 */
		arcane function get viewWidth():Number
		{
			return _viewWidth;
		}

		arcane function set viewWidth(value:Number):void
		{
			_viewWidth = value;
		}

		/**
		 * 窗口高度
		 */
		arcane function get viewHeight():Number
		{
			return _viewHeight;
		}

		arcane function set viewHeight(value:Number):void
		{
			_viewHeight = value;
		}

		/**
		 * 背景颜色透明度部分
		 */
		arcane function get backgroundAlpha():Number
		{
			return _backgroundAlpha;
		}

		arcane function set backgroundAlpha(value:Number):void
		{
			_backgroundAlpha = value;
		}

		/**
		 * 背景颜色红色部分
		 */
		arcane function get backgroundR():Number
		{
			return _backgroundR;
		}

		arcane function set backgroundR(value:Number):void
		{
			_backgroundR = value;
		}

		/**
		 * 背景颜色绿色部分
		 */
		arcane function get backgroundG():Number
		{
			return _backgroundG;
		}

		arcane function set backgroundG(value:Number):void
		{
			_backgroundG = value;
		}

		/**
		 * 背景颜色蓝色部分
		 */
		arcane function get backgroundB():Number
		{
			return _backgroundB;
		}

		arcane function set backgroundB(value:Number):void
		{
			_backgroundB = value;
		}

		/**
		 * Disposes the resources used by the RendererBase.
		 *
		 * @private
		 */
		arcane function dispose():void
		{
			stage3DProxy = null;
		}

		/**
		 * Renders the potentially visible geometry to the back buffer or texture.
		 * @param entityCollector The EntityCollector object containing the potentially visible geometry.
		 * @param target An option target texture to render to.
		 * @param surfaceSelector The index of a CubeTexture's face to render to.
		 * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
		 */
		arcane function render(entityCollector:EntityCollector, target:TextureBase = null, scissorRect:Rectangle = null, surfaceSelector:int = 0):void
		{
			if (!_stage3DProxy || !_context)
				return;

			_rttViewProjectionMatrix.copyFrom(entityCollector.camera.viewProjection);
			_rttViewProjectionMatrix.appendScale(_textureRatioX, _textureRatioY, 1);

			executeRender(entityCollector, target, scissorRect, surfaceSelector);

			// clear buffers
			for (var i:uint = 0; i < 8; ++i)
			{
				_context.setVertexBufferAt(i, null);
				_context.setTextureAt(i, null);
			}
		}

		/**
		 * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
		 * @param entityCollector The EntityCollector object containing the potentially visible geometry.
		 * @param target An option target texture to render to.
		 * @param surfaceSelector The index of a CubeTexture's face to render to.
		 * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
		 */
		protected function executeRender(entityCollector:EntityCollector, target:TextureBase = null, scissorRect:Rectangle = null, surfaceSelector:int = 0):void
		{
			_renderTarget = target;
			_renderTargetSurface = surfaceSelector;

			if (_renderableSorter)
				_renderableSorter.sort(entityCollector);

			if ((target || !_shareContext) && _clearOnRender)
				_context.clear(_backgroundR, _backgroundG, _backgroundB, _backgroundAlpha, 1, 0);
			_context.setDepthTest(false, Context3DCompareMode.ALWAYS);
			_stage3DProxy.scissorRect = scissorRect;

			draw(entityCollector, target);

			//line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
			_context.setDepthTest(false, Context3DCompareMode.LESS_EQUAL);

			_stage3DProxy.scissorRect = null;
		}

		/**
		 * Performs the actual drawing of geometry to the target.
		 * @param entityCollector The EntityCollector object containing the potentially visible geometry.
		 */
		protected function draw(entityCollector:EntityCollector, target:TextureBase):void
		{
			throw new AbstractMethodError();
		}
	}
}
